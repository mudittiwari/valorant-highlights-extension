{
  "version": 3,
  "sources": ["../../dequal/lite/index.mjs", "../../async-mutex/index.mjs", "../../@wxt-dev/storage/dist/index.mjs"],
  "sourcesContent": ["var has = Object.prototype.hasOwnProperty;\n\nexport function dequal(foo, bar) {\n\tvar ctor, len;\n\tif (foo === bar) return true;\n\n\tif (foo && bar && (ctor=foo.constructor) === bar.constructor) {\n\t\tif (ctor === Date) return foo.getTime() === bar.getTime();\n\t\tif (ctor === RegExp) return foo.toString() === bar.toString();\n\n\t\tif (ctor === Array) {\n\t\t\tif ((len=foo.length) === bar.length) {\n\t\t\t\twhile (len-- && dequal(foo[len], bar[len]));\n\t\t\t}\n\t\t\treturn len === -1;\n\t\t}\n\n\t\tif (!ctor || typeof foo === 'object') {\n\t\t\tlen = 0;\n\t\t\tfor (ctor in foo) {\n\t\t\t\tif (has.call(foo, ctor) && ++len && !has.call(bar, ctor)) return false;\n\t\t\t\tif (!(ctor in bar) || !dequal(foo[ctor], bar[ctor])) return false;\n\t\t\t}\n\t\t\treturn Object.keys(bar).length === len;\n\t\t}\n\t}\n\n\treturn foo !== foo && bar !== bar;\n}\n", "const E_TIMEOUT = new Error('timeout while waiting for mutex to become available');\nconst E_ALREADY_LOCKED = new Error('mutex already locked');\nconst E_CANCELED = new Error('request for lock canceled');\n\nvar __awaiter$2 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nclass Semaphore {\n    constructor(_value, _cancelError = E_CANCELED) {\n        this._value = _value;\n        this._cancelError = _cancelError;\n        this._queue = [];\n        this._weightedWaiters = [];\n    }\n    acquire(weight = 1, priority = 0) {\n        if (weight <= 0)\n            throw new Error(`invalid weight ${weight}: must be positive`);\n        return new Promise((resolve, reject) => {\n            const task = { resolve, reject, weight, priority };\n            const i = findIndexFromEnd(this._queue, (other) => priority <= other.priority);\n            if (i === -1 && weight <= this._value) {\n                // Needs immediate dispatch, skip the queue\n                this._dispatchItem(task);\n            }\n            else {\n                this._queue.splice(i + 1, 0, task);\n            }\n        });\n    }\n    runExclusive(callback_1) {\n        return __awaiter$2(this, arguments, void 0, function* (callback, weight = 1, priority = 0) {\n            const [value, release] = yield this.acquire(weight, priority);\n            try {\n                return yield callback(value);\n            }\n            finally {\n                release();\n            }\n        });\n    }\n    waitForUnlock(weight = 1, priority = 0) {\n        if (weight <= 0)\n            throw new Error(`invalid weight ${weight}: must be positive`);\n        if (this._couldLockImmediately(weight, priority)) {\n            return Promise.resolve();\n        }\n        else {\n            return new Promise((resolve) => {\n                if (!this._weightedWaiters[weight - 1])\n                    this._weightedWaiters[weight - 1] = [];\n                insertSorted(this._weightedWaiters[weight - 1], { resolve, priority });\n            });\n        }\n    }\n    isLocked() {\n        return this._value <= 0;\n    }\n    getValue() {\n        return this._value;\n    }\n    setValue(value) {\n        this._value = value;\n        this._dispatchQueue();\n    }\n    release(weight = 1) {\n        if (weight <= 0)\n            throw new Error(`invalid weight ${weight}: must be positive`);\n        this._value += weight;\n        this._dispatchQueue();\n    }\n    cancel() {\n        this._queue.forEach((entry) => entry.reject(this._cancelError));\n        this._queue = [];\n    }\n    _dispatchQueue() {\n        this._drainUnlockWaiters();\n        while (this._queue.length > 0 && this._queue[0].weight <= this._value) {\n            this._dispatchItem(this._queue.shift());\n            this._drainUnlockWaiters();\n        }\n    }\n    _dispatchItem(item) {\n        const previousValue = this._value;\n        this._value -= item.weight;\n        item.resolve([previousValue, this._newReleaser(item.weight)]);\n    }\n    _newReleaser(weight) {\n        let called = false;\n        return () => {\n            if (called)\n                return;\n            called = true;\n            this.release(weight);\n        };\n    }\n    _drainUnlockWaiters() {\n        if (this._queue.length === 0) {\n            for (let weight = this._value; weight > 0; weight--) {\n                const waiters = this._weightedWaiters[weight - 1];\n                if (!waiters)\n                    continue;\n                waiters.forEach((waiter) => waiter.resolve());\n                this._weightedWaiters[weight - 1] = [];\n            }\n        }\n        else {\n            const queuedPriority = this._queue[0].priority;\n            for (let weight = this._value; weight > 0; weight--) {\n                const waiters = this._weightedWaiters[weight - 1];\n                if (!waiters)\n                    continue;\n                const i = waiters.findIndex((waiter) => waiter.priority <= queuedPriority);\n                (i === -1 ? waiters : waiters.splice(0, i))\n                    .forEach((waiter => waiter.resolve()));\n            }\n        }\n    }\n    _couldLockImmediately(weight, priority) {\n        return (this._queue.length === 0 || this._queue[0].priority < priority) &&\n            weight <= this._value;\n    }\n}\nfunction insertSorted(a, v) {\n    const i = findIndexFromEnd(a, (other) => v.priority <= other.priority);\n    a.splice(i + 1, 0, v);\n}\nfunction findIndexFromEnd(a, predicate) {\n    for (let i = a.length - 1; i >= 0; i--) {\n        if (predicate(a[i])) {\n            return i;\n        }\n    }\n    return -1;\n}\n\nvar __awaiter$1 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nclass Mutex {\n    constructor(cancelError) {\n        this._semaphore = new Semaphore(1, cancelError);\n    }\n    acquire() {\n        return __awaiter$1(this, arguments, void 0, function* (priority = 0) {\n            const [, releaser] = yield this._semaphore.acquire(1, priority);\n            return releaser;\n        });\n    }\n    runExclusive(callback, priority = 0) {\n        return this._semaphore.runExclusive(() => callback(), 1, priority);\n    }\n    isLocked() {\n        return this._semaphore.isLocked();\n    }\n    waitForUnlock(priority = 0) {\n        return this._semaphore.waitForUnlock(1, priority);\n    }\n    release() {\n        if (this._semaphore.isLocked())\n            this._semaphore.release();\n    }\n    cancel() {\n        return this._semaphore.cancel();\n    }\n}\n\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nfunction withTimeout(sync, timeout, timeoutError = E_TIMEOUT) {\n    return {\n        acquire: (weightOrPriority, priority) => {\n            let weight;\n            if (isSemaphore(sync)) {\n                weight = weightOrPriority;\n            }\n            else {\n                weight = undefined;\n                priority = weightOrPriority;\n            }\n            if (weight !== undefined && weight <= 0) {\n                throw new Error(`invalid weight ${weight}: must be positive`);\n            }\n            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n                let isTimeout = false;\n                const handle = setTimeout(() => {\n                    isTimeout = true;\n                    reject(timeoutError);\n                }, timeout);\n                try {\n                    const ticket = yield (isSemaphore(sync)\n                        ? sync.acquire(weight, priority)\n                        : sync.acquire(priority));\n                    if (isTimeout) {\n                        const release = Array.isArray(ticket) ? ticket[1] : ticket;\n                        release();\n                    }\n                    else {\n                        clearTimeout(handle);\n                        resolve(ticket);\n                    }\n                }\n                catch (e) {\n                    if (!isTimeout) {\n                        clearTimeout(handle);\n                        reject(e);\n                    }\n                }\n            }));\n        },\n        runExclusive(callback, weight, priority) {\n            return __awaiter(this, void 0, void 0, function* () {\n                let release = () => undefined;\n                try {\n                    const ticket = yield this.acquire(weight, priority);\n                    if (Array.isArray(ticket)) {\n                        release = ticket[1];\n                        return yield callback(ticket[0]);\n                    }\n                    else {\n                        release = ticket;\n                        return yield callback();\n                    }\n                }\n                finally {\n                    release();\n                }\n            });\n        },\n        release(weight) {\n            sync.release(weight);\n        },\n        cancel() {\n            return sync.cancel();\n        },\n        waitForUnlock: (weightOrPriority, priority) => {\n            let weight;\n            if (isSemaphore(sync)) {\n                weight = weightOrPriority;\n            }\n            else {\n                weight = undefined;\n                priority = weightOrPriority;\n            }\n            if (weight !== undefined && weight <= 0) {\n                throw new Error(`invalid weight ${weight}: must be positive`);\n            }\n            return new Promise((resolve, reject) => {\n                const handle = setTimeout(() => reject(timeoutError), timeout);\n                (isSemaphore(sync)\n                    ? sync.waitForUnlock(weight, priority)\n                    : sync.waitForUnlock(priority)).then(() => {\n                    clearTimeout(handle);\n                    resolve();\n                });\n            });\n        },\n        isLocked: () => sync.isLocked(),\n        getValue: () => sync.getValue(),\n        setValue: (value) => sync.setValue(value),\n    };\n}\nfunction isSemaphore(sync) {\n    return sync.getValue !== undefined;\n}\n\n// eslint-disable-next-lisne @typescript-eslint/explicit-module-boundary-types\nfunction tryAcquire(sync, alreadyAcquiredError = E_ALREADY_LOCKED) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return withTimeout(sync, 0, alreadyAcquiredError);\n}\n\nexport { E_ALREADY_LOCKED, E_CANCELED, E_TIMEOUT, Mutex, Semaphore, tryAcquire, withTimeout };\n", "import { dequal } from 'dequal/lite';\nimport { Mutex } from 'async-mutex';\n\nconst browser = (\n  // @ts-expect-error\n  globalThis.browser?.runtime?.id == null ? globalThis.chrome : (\n    // @ts-expect-error\n    globalThis.browser\n  )\n);\nconst storage = createStorage();\nfunction createStorage() {\n  const drivers = {\n    local: createDriver(\"local\"),\n    session: createDriver(\"session\"),\n    sync: createDriver(\"sync\"),\n    managed: createDriver(\"managed\")\n  };\n  const getDriver = (area) => {\n    const driver = drivers[area];\n    if (driver == null) {\n      const areaNames = Object.keys(drivers).join(\", \");\n      throw Error(`Invalid area \"${area}\". Options: ${areaNames}`);\n    }\n    return driver;\n  };\n  const resolveKey = (key) => {\n    const deliminatorIndex = key.indexOf(\":\");\n    const driverArea = key.substring(0, deliminatorIndex);\n    const driverKey = key.substring(deliminatorIndex + 1);\n    if (driverKey == null)\n      throw Error(\n        `Storage key should be in the form of \"area:key\", but received \"${key}\"`\n      );\n    return {\n      driverArea,\n      driverKey,\n      driver: getDriver(driverArea)\n    };\n  };\n  const getMetaKey = (key) => key + \"$\";\n  const mergeMeta = (oldMeta, newMeta) => {\n    const newFields = { ...oldMeta };\n    Object.entries(newMeta).forEach(([key, value]) => {\n      if (value == null)\n        delete newFields[key];\n      else\n        newFields[key] = value;\n    });\n    return newFields;\n  };\n  const getValueOrFallback = (value, fallback) => value ?? fallback ?? null;\n  const getMetaValue = (properties) => typeof properties === \"object\" && !Array.isArray(properties) ? properties : {};\n  const getItem = async (driver, driverKey, opts) => {\n    const res = await driver.getItem(driverKey);\n    return getValueOrFallback(res, opts?.fallback ?? opts?.defaultValue);\n  };\n  const getMeta = async (driver, driverKey) => {\n    const metaKey = getMetaKey(driverKey);\n    const res = await driver.getItem(metaKey);\n    return getMetaValue(res);\n  };\n  const setItem = async (driver, driverKey, value) => {\n    await driver.setItem(driverKey, value ?? null);\n  };\n  const setMeta = async (driver, driverKey, properties) => {\n    const metaKey = getMetaKey(driverKey);\n    const existingFields = getMetaValue(await driver.getItem(metaKey));\n    await driver.setItem(metaKey, mergeMeta(existingFields, properties));\n  };\n  const removeItem = async (driver, driverKey, opts) => {\n    await driver.removeItem(driverKey);\n    if (opts?.removeMeta) {\n      const metaKey = getMetaKey(driverKey);\n      await driver.removeItem(metaKey);\n    }\n  };\n  const removeMeta = async (driver, driverKey, properties) => {\n    const metaKey = getMetaKey(driverKey);\n    if (properties == null) {\n      await driver.removeItem(metaKey);\n    } else {\n      const newFields = getMetaValue(await driver.getItem(metaKey));\n      [properties].flat().forEach((field) => delete newFields[field]);\n      await driver.setItem(metaKey, newFields);\n    }\n  };\n  const watch = (driver, driverKey, cb) => {\n    return driver.watch(driverKey, cb);\n  };\n  const storage2 = {\n    getItem: async (key, opts) => {\n      const { driver, driverKey } = resolveKey(key);\n      return await getItem(driver, driverKey, opts);\n    },\n    getItems: async (keys) => {\n      const areaToKeyMap = /* @__PURE__ */ new Map();\n      const keyToOptsMap = /* @__PURE__ */ new Map();\n      const orderedKeys = [];\n      keys.forEach((key) => {\n        let keyStr;\n        let opts;\n        if (typeof key === \"string\") {\n          keyStr = key;\n        } else if (\"getValue\" in key) {\n          keyStr = key.key;\n          opts = { fallback: key.fallback };\n        } else {\n          keyStr = key.key;\n          opts = key.options;\n        }\n        orderedKeys.push(keyStr);\n        const { driverArea, driverKey } = resolveKey(keyStr);\n        const areaKeys = areaToKeyMap.get(driverArea) ?? [];\n        areaToKeyMap.set(driverArea, areaKeys.concat(driverKey));\n        keyToOptsMap.set(keyStr, opts);\n      });\n      const resultsMap = /* @__PURE__ */ new Map();\n      await Promise.all(\n        Array.from(areaToKeyMap.entries()).map(async ([driverArea, keys2]) => {\n          const driverResults = await drivers[driverArea].getItems(keys2);\n          driverResults.forEach((driverResult) => {\n            const key = `${driverArea}:${driverResult.key}`;\n            const opts = keyToOptsMap.get(key);\n            const value = getValueOrFallback(\n              driverResult.value,\n              opts?.fallback ?? opts?.defaultValue\n            );\n            resultsMap.set(key, value);\n          });\n        })\n      );\n      return orderedKeys.map((key) => ({\n        key,\n        value: resultsMap.get(key)\n      }));\n    },\n    getMeta: async (key) => {\n      const { driver, driverKey } = resolveKey(key);\n      return await getMeta(driver, driverKey);\n    },\n    getMetas: async (args) => {\n      const keys = args.map((arg) => {\n        const key = typeof arg === \"string\" ? arg : arg.key;\n        const { driverArea, driverKey } = resolveKey(key);\n        return {\n          key,\n          driverArea,\n          driverKey,\n          driverMetaKey: getMetaKey(driverKey)\n        };\n      });\n      const areaToDriverMetaKeysMap = keys.reduce((map, key) => {\n        var _a;\n        map[_a = key.driverArea] ?? (map[_a] = []);\n        map[key.driverArea].push(key);\n        return map;\n      }, {});\n      const resultsMap = {};\n      await Promise.all(\n        Object.entries(areaToDriverMetaKeysMap).map(async ([area, keys2]) => {\n          const areaRes = await browser.storage[area].get(\n            keys2.map((key) => key.driverMetaKey)\n          );\n          keys2.forEach((key) => {\n            resultsMap[key.key] = areaRes[key.driverMetaKey] ?? {};\n          });\n        })\n      );\n      return keys.map((key) => ({\n        key: key.key,\n        meta: resultsMap[key.key]\n      }));\n    },\n    setItem: async (key, value) => {\n      const { driver, driverKey } = resolveKey(key);\n      await setItem(driver, driverKey, value);\n    },\n    setItems: async (items) => {\n      const areaToKeyValueMap = {};\n      items.forEach((item) => {\n        const { driverArea, driverKey } = resolveKey(\n          \"key\" in item ? item.key : item.item.key\n        );\n        areaToKeyValueMap[driverArea] ?? (areaToKeyValueMap[driverArea] = []);\n        areaToKeyValueMap[driverArea].push({\n          key: driverKey,\n          value: item.value\n        });\n      });\n      await Promise.all(\n        Object.entries(areaToKeyValueMap).map(async ([driverArea, values]) => {\n          const driver = getDriver(driverArea);\n          await driver.setItems(values);\n        })\n      );\n    },\n    setMeta: async (key, properties) => {\n      const { driver, driverKey } = resolveKey(key);\n      await setMeta(driver, driverKey, properties);\n    },\n    setMetas: async (items) => {\n      const areaToMetaUpdatesMap = {};\n      items.forEach((item) => {\n        const { driverArea, driverKey } = resolveKey(\n          \"key\" in item ? item.key : item.item.key\n        );\n        areaToMetaUpdatesMap[driverArea] ?? (areaToMetaUpdatesMap[driverArea] = []);\n        areaToMetaUpdatesMap[driverArea].push({\n          key: driverKey,\n          properties: item.meta\n        });\n      });\n      await Promise.all(\n        Object.entries(areaToMetaUpdatesMap).map(\n          async ([storageArea, updates]) => {\n            const driver = getDriver(storageArea);\n            const metaKeys = updates.map(({ key }) => getMetaKey(key));\n            console.log(storageArea, metaKeys);\n            const existingMetas = await driver.getItems(metaKeys);\n            const existingMetaMap = Object.fromEntries(\n              existingMetas.map(({ key, value }) => [key, getMetaValue(value)])\n            );\n            const metaUpdates = updates.map(({ key, properties }) => {\n              const metaKey = getMetaKey(key);\n              return {\n                key: metaKey,\n                value: mergeMeta(existingMetaMap[metaKey] ?? {}, properties)\n              };\n            });\n            await driver.setItems(metaUpdates);\n          }\n        )\n      );\n    },\n    removeItem: async (key, opts) => {\n      const { driver, driverKey } = resolveKey(key);\n      await removeItem(driver, driverKey, opts);\n    },\n    removeItems: async (keys) => {\n      const areaToKeysMap = {};\n      keys.forEach((key) => {\n        let keyStr;\n        let opts;\n        if (typeof key === \"string\") {\n          keyStr = key;\n        } else if (\"getValue\" in key) {\n          keyStr = key.key;\n        } else if (\"item\" in key) {\n          keyStr = key.item.key;\n          opts = key.options;\n        } else {\n          keyStr = key.key;\n          opts = key.options;\n        }\n        const { driverArea, driverKey } = resolveKey(keyStr);\n        areaToKeysMap[driverArea] ?? (areaToKeysMap[driverArea] = []);\n        areaToKeysMap[driverArea].push(driverKey);\n        if (opts?.removeMeta) {\n          areaToKeysMap[driverArea].push(getMetaKey(driverKey));\n        }\n      });\n      await Promise.all(\n        Object.entries(areaToKeysMap).map(async ([driverArea, keys2]) => {\n          const driver = getDriver(driverArea);\n          await driver.removeItems(keys2);\n        })\n      );\n    },\n    removeMeta: async (key, properties) => {\n      const { driver, driverKey } = resolveKey(key);\n      await removeMeta(driver, driverKey, properties);\n    },\n    snapshot: async (base, opts) => {\n      const driver = getDriver(base);\n      const data = await driver.snapshot();\n      opts?.excludeKeys?.forEach((key) => {\n        delete data[key];\n        delete data[getMetaKey(key)];\n      });\n      return data;\n    },\n    restoreSnapshot: async (base, data) => {\n      const driver = getDriver(base);\n      await driver.restoreSnapshot(data);\n    },\n    watch: (key, cb) => {\n      const { driver, driverKey } = resolveKey(key);\n      return watch(driver, driverKey, cb);\n    },\n    unwatch() {\n      Object.values(drivers).forEach((driver) => {\n        driver.unwatch();\n      });\n    },\n    defineItem: (key, opts) => {\n      const { driver, driverKey } = resolveKey(key);\n      const { version: targetVersion = 1, migrations = {} } = opts ?? {};\n      if (targetVersion < 1) {\n        throw Error(\n          \"Storage item version cannot be less than 1. Initial versions should be set to 1, not 0.\"\n        );\n      }\n      const migrate = async () => {\n        const driverMetaKey = getMetaKey(driverKey);\n        const [{ value }, { value: meta }] = await driver.getItems([\n          driverKey,\n          driverMetaKey\n        ]);\n        if (value == null)\n          return;\n        const currentVersion = meta?.v ?? 1;\n        if (currentVersion > targetVersion) {\n          throw Error(\n            `Version downgrade detected (v${currentVersion} -> v${targetVersion}) for \"${key}\"`\n          );\n        }\n        console.debug(\n          `[@wxt-dev/storage] Running storage migration for ${key}: v${currentVersion} -> v${targetVersion}`\n        );\n        const migrationsToRun = Array.from(\n          { length: targetVersion - currentVersion },\n          (_, i) => currentVersion + i + 1\n        );\n        let migratedValue = value;\n        for (const migrateToVersion of migrationsToRun) {\n          try {\n            migratedValue = await migrations?.[migrateToVersion]?.(migratedValue) ?? migratedValue;\n          } catch (err) {\n            throw Error(`v${migrateToVersion} migration failed for \"${key}\"`, {\n              cause: err\n            });\n          }\n        }\n        await driver.setItems([\n          { key: driverKey, value: migratedValue },\n          { key: driverMetaKey, value: { ...meta, v: targetVersion } }\n        ]);\n        console.debug(\n          `[@wxt-dev/storage] Storage migration completed for ${key} v${targetVersion}`,\n          { migratedValue }\n        );\n      };\n      const migrationsDone = opts?.migrations == null ? Promise.resolve() : migrate().catch((err) => {\n        console.error(\n          `[@wxt-dev/storage] Migration failed for ${key}`,\n          err\n        );\n      });\n      const initMutex = new Mutex();\n      const getFallback = () => opts?.fallback ?? opts?.defaultValue ?? null;\n      const getOrInitValue = () => initMutex.runExclusive(async () => {\n        const value = await driver.getItem(driverKey);\n        if (value != null || opts?.init == null)\n          return value;\n        const newValue = await opts.init();\n        await driver.setItem(driverKey, newValue);\n        return newValue;\n      });\n      migrationsDone.then(getOrInitValue);\n      return {\n        key,\n        get defaultValue() {\n          return getFallback();\n        },\n        get fallback() {\n          return getFallback();\n        },\n        getValue: async () => {\n          await migrationsDone;\n          if (opts?.init) {\n            return await getOrInitValue();\n          } else {\n            return await getItem(driver, driverKey, opts);\n          }\n        },\n        getMeta: async () => {\n          await migrationsDone;\n          return await getMeta(driver, driverKey);\n        },\n        setValue: async (value) => {\n          await migrationsDone;\n          return await setItem(driver, driverKey, value);\n        },\n        setMeta: async (properties) => {\n          await migrationsDone;\n          return await setMeta(driver, driverKey, properties);\n        },\n        removeValue: async (opts2) => {\n          await migrationsDone;\n          return await removeItem(driver, driverKey, opts2);\n        },\n        removeMeta: async (properties) => {\n          await migrationsDone;\n          return await removeMeta(driver, driverKey, properties);\n        },\n        watch: (cb) => watch(\n          driver,\n          driverKey,\n          (newValue, oldValue) => cb(newValue ?? getFallback(), oldValue ?? getFallback())\n        ),\n        migrate\n      };\n    }\n  };\n  return storage2;\n}\nfunction createDriver(storageArea) {\n  const getStorageArea = () => {\n    if (browser.runtime == null) {\n      throw Error(\n        [\n          \"'wxt/storage' must be loaded in a web extension environment\",\n          \"\\n - If thrown during a build, see https://github.com/wxt-dev/wxt/issues/371\",\n          \" - If thrown during tests, mock 'wxt/browser' correctly. See https://wxt.dev/guide/go-further/testing.html\\n\"\n        ].join(\"\\n\")\n      );\n    }\n    if (browser.storage == null) {\n      throw Error(\n        \"You must add the 'storage' permission to your manifest to use 'wxt/storage'\"\n      );\n    }\n    const area = browser.storage[storageArea];\n    if (area == null)\n      throw Error(`\"browser.storage.${storageArea}\" is undefined`);\n    return area;\n  };\n  const watchListeners = /* @__PURE__ */ new Set();\n  return {\n    getItem: async (key) => {\n      const res = await getStorageArea().get(key);\n      return res[key];\n    },\n    getItems: async (keys) => {\n      const result = await getStorageArea().get(keys);\n      return keys.map((key) => ({ key, value: result[key] ?? null }));\n    },\n    setItem: async (key, value) => {\n      if (value == null) {\n        await getStorageArea().remove(key);\n      } else {\n        await getStorageArea().set({ [key]: value });\n      }\n    },\n    setItems: async (values) => {\n      const map = values.reduce(\n        (map2, { key, value }) => {\n          map2[key] = value;\n          return map2;\n        },\n        {}\n      );\n      await getStorageArea().set(map);\n    },\n    removeItem: async (key) => {\n      await getStorageArea().remove(key);\n    },\n    removeItems: async (keys) => {\n      await getStorageArea().remove(keys);\n    },\n    snapshot: async () => {\n      return await getStorageArea().get();\n    },\n    restoreSnapshot: async (data) => {\n      await getStorageArea().set(data);\n    },\n    watch(key, cb) {\n      const listener = (changes) => {\n        const change = changes[key];\n        if (change == null)\n          return;\n        if (dequal(change.newValue, change.oldValue))\n          return;\n        cb(change.newValue ?? null, change.oldValue ?? null);\n      };\n      getStorageArea().onChanged.addListener(listener);\n      watchListeners.add(listener);\n      return () => {\n        getStorageArea().onChanged.removeListener(listener);\n        watchListeners.delete(listener);\n      };\n    },\n    unwatch() {\n      watchListeners.forEach((listener) => {\n        getStorageArea().onChanged.removeListener(listener);\n      });\n      watchListeners.clear();\n    }\n  };\n}\nclass MigrationError extends Error {\n  constructor(key, version, options) {\n    super(`v${version} migration failed for \"${key}\"`, options);\n    this.key = key;\n    this.version = version;\n  }\n}\n\nexport { MigrationError, storage };\n"],
  "mappings": "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",
  "names": ["_a"]
}
